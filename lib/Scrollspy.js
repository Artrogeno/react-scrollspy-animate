var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import Helpers from './helpers';

export default class Scrollspy extends React.Component {
  static get propTypes() {
    return {
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      componentClass: PropTypes.string,
      scrolledPastClassName: PropTypes.string,
      active: PropTypes.string,
      level: PropTypes.number,
      offset: PropTypes.number,
      timeout: PropTypes.number,
      rootEl: PropTypes.string,
      animete: PropTypes.object,
      onUpdate: PropTypes.func
    };
  }

  static get defaultProps() {
    return {
      tag: 'ul',
      componentClass: '',
      active: 'active',
      level: 1,
      offset: 0,
      timeout: 500,
      animete: { behavior: 'smooth', block: 'start' },
      onUpdate() {}
    };
  }

  constructor(props) {
    super(props);
    this.state = {
      targetItems: [],
      inViewState: [],
      isScrolledPast: [],
      items: []
    };
    this._handleSpy = this._handleSpy.bind(this);
    this.goScrollTag = this.goScrollTag.bind(this);
  }

  _initProps() {
    let childrenTag = [],
        { children } = this.props;
    React.Children.map(children, child => {
      if (!child) {
        return null;
      }
      let tmpChild = this._getLevelChildren(child.props);
      if (tmpChild) {
        childrenTag.push(tmpChild);
      }
    });

    const targetItems = this._initSpyTargetItems(childrenTag);
    this.setState({
      targetItems
    });

    this._spy(targetItems);
  }

  _setListItems() {
    let items = [],
        { children } = this.props;
    React.Children.map(children, child => {
      if (!child) {
        return null;
      }
      let tmpChild = this._getLevelChildren(child.props);
      if (tmpChild) {
        items.push(tmpChild);
      }
    });
    this.setState({ items });
  }

  _spy(targets) {
    const elemensViewState = this._getElemsViewState(targets);
    const currentStatuses = this.state.inViewState;

    this.setState({
      inViewState: elemensViewState.viewStatusList,
      isScrolledPast: elemensViewState.scrolledPast
    }, () => {
      this._update(currentStatuses);
    });
  }

  _handleSpy() {
    Helpers.throttle(this._spy(), 100);
  }

  goScrollTag(event, tag) {
    event.stopPropagation();
    event.preventDefault();

    const { animete, timeout } = this.props;
    document.getElementById(tag).scrollIntoView(animete);

    setTimeout(() => {
      window.location.hash = '#' + tag;
    }, timeout);
  }

  // OLDERS
  _getLevelChildren(child) {
    let resultChildren = [],
        { level } = this.props;
    for (let i = 0; i < level; i++) {
      resultChildren = child.children.props;
    }
    if (!resultChildren.href) {
      return;
    }
    return resultChildren.href.split('#')[1];
  }

  _initSpyTargetItems(items) {
    return items.map(item => {
      return document.getElementById(item);
    });
  }

  _getElemsViewState(targets) {
    const targetItems = targets ? targets : this.state.targetItems;
    let hasInViewAlready = false;
    let elemsInView = [];
    let elemsOutView = [];
    let viewStatusList = [];

    for (let i = 0, max = targetItems.length; i < max; i++) {
      let currentContent = targetItems[i];
      let isInView = hasInViewAlready ? false : this._isInView(currentContent);
      if (isInView) {
        hasInViewAlready = true;
        elemsInView.push(currentContent);
      } else {
        elemsOutView.push(currentContent);
      }

      const isLastItem = i === max - 1;
      const isScrolled = this._isScrolled();
      const isLastShortItemAtBottom = this._isAtBottom() && this._isInView(currentContent) && !isInView && isLastItem && isScrolled;

      if (isLastShortItemAtBottom) {
        elemsOutView.pop();
        elemsOutView.push(...elemsInView);
        elemsInView = [currentContent];
        viewStatusList = Helpers.fillArray(viewStatusList, false);
        isInView = true;
      }

      viewStatusList.push(isInView);
    }

    return {
      inView: elemsInView,
      outView: elemsOutView,
      viewStatusList,
      scrolledPast: this.props.scrolledPastClassName && this._getScrolledPast(viewStatusList)
    };
  }

  _isInView(el) {
    if (!el) {
      return false;
    }
    const { rootEl, offset } = this.props;
    let rootRect;
    if (rootEl) {
      rootRect = document.querySelector(rootEl).getBoundingClientRect();
    }

    const rect = el.getBoundingClientRect();
    const winH = rootEl ? rootRect.height : window.innerHeight;
    const { scrollTop } = this._getScrollDimension();
    const scrollBottom = scrollTop + winH;
    const elTop = rootEl ? rect.top + scrollTop - rootRect.top + offset : rect.top + scrollTop + offset;
    const elBottom = elTop + el.offsetHeight;

    return elTop < scrollBottom && elBottom > scrollTop;
  }

  _getScrollDimension() {
    const { rootEl } = this.props;
    const scrollTop = rootEl ? document.querySelector(rootEl).scrollTop : document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop;
    const scrollHeight = rootEl ? document.querySelector(rootEl).scrollHeight : document.documentElement.scrollHeight || document.body.parentNode.scrollHeight || document.body.scrollHeight;
    return { scrollTop, scrollHeight };
  }

  _isAtBottom() {
    const { rootEl } = this.props;
    const { scrollTop, scrollHeight } = this._getScrollDimension();
    const winH = rootEl ? document.querySelector(rootEl).getBoundingClientRect().height : window.innerHeight;
    const scrolledToBottom = scrollTop + winH >= scrollHeight;
    return scrolledToBottom;
  }

  _isScrolled() {
    return this._getScrollDimension().scrollTop > 0;
  }

  _getScrolledPast(viewStatusList) {
    if (!viewStatusList.some(item => item)) {
      return viewStatusList;
    }
    let hasFoundInView = false;
    const scrolledPastItems = viewStatusList.map(item => {
      if (item && !hasFoundInView) {
        hasFoundInView = true;
        return false;
      }
      return !hasFoundInView;
    });
    return scrolledPastItems;
  }

  _update(prevStatuses) {
    const { inViewState, targetItems } = this.state;
    if (Helpers.isEqualArray(inViewState, prevStatuses)) {
      return;
    }
    this.props.onUpdate(targetItems[inViewState.indexOf(true)]);
  }

  offEvent() {
    let { rootEl } = this.props;
    const el = rootEl ? document.querySelector(rootEl) : window;
    el.removeEventListener('scroll', this._handleSpy);
  }

  onEvent() {
    let { rootEl } = this.props;
    const el = rootEl ? document.querySelector(rootEl) : window;
    el.addEventListener('scroll', this._handleSpy);
  }

  componentDidMount() {
    this._initProps();
    this._setListItems();
    this.onEvent();
  }

  componentWillUnmount() {
    this.offEvent();
  }

  componentWillReceiveProps() {
    this._initFromProps();
  }

  _setScrollSelectNav() {
    this.onEvent();
    const { inViewState, items } = this.state;
    if (inViewState.indexOf(true) !== -1) {
      let hash,
          currentHash,
          indexView = inViewState.indexOf(true);
      hash = items[indexView];
      currentHash = window.location.hash.split('#')[1];
      let currentIndex = items.indexOf(currentHash);
      if (hash) {
        if (currentIndex < indexView) {
          window.location.hash = '#' + hash;
        }
      }
    }
  }

  render() {
    const { children, className = '', tag } = this.props;
    const { inViewState } = this.state;
    const TagComponent = tag;
    let counter = 0;
    const items = React.Children.map(children, (child, idx) => {
      if (!child) {
        return null;
      }
      const ChildTag = child.type;
      const elementID = this._getLevelChildren(child.props);
      const childClass = classNames({
        [`${child.props.className}`]: child.props.className || '',
        [`${this.props.active}`]: inViewState[idx]
      });
      this._setScrollSelectNav();
      return React.createElement(
        ChildTag,
        _extends({}, child.props, { className: childClass, key: counter++, onClick: event => this.goScrollTag(event, elementID) }),
        child.props.children
      );
    });

    return React.createElement(
      TagComponent,
      { className: className },
      items
    );
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uL3NyYy9saWIvU2Nyb2xsc3B5LmpzIl0sIm5hbWVzIjpbIlJlYWN0IiwiUHJvcFR5cGVzIiwiY2xhc3NOYW1lcyIsIkhlbHBlcnMiLCJTY3JvbGxzcHkiLCJDb21wb25lbnQiLCJwcm9wVHlwZXMiLCJ0YWciLCJvbmVPZlR5cGUiLCJzdHJpbmciLCJmdW5jIiwiY29tcG9uZW50Q2xhc3MiLCJzY3JvbGxlZFBhc3RDbGFzc05hbWUiLCJhY3RpdmUiLCJsZXZlbCIsIm51bWJlciIsIm9mZnNldCIsInRpbWVvdXQiLCJyb290RWwiLCJhbmltZXRlIiwib2JqZWN0Iiwib25VcGRhdGUiLCJkZWZhdWx0UHJvcHMiLCJiZWhhdmlvciIsImJsb2NrIiwiY29uc3RydWN0b3IiLCJwcm9wcyIsInN0YXRlIiwidGFyZ2V0SXRlbXMiLCJpblZpZXdTdGF0ZSIsImlzU2Nyb2xsZWRQYXN0IiwiaXRlbXMiLCJfaGFuZGxlU3B5IiwiYmluZCIsImdvU2Nyb2xsVGFnIiwiX2luaXRQcm9wcyIsImNoaWxkcmVuVGFnIiwiY2hpbGRyZW4iLCJDaGlsZHJlbiIsIm1hcCIsImNoaWxkIiwidG1wQ2hpbGQiLCJfZ2V0TGV2ZWxDaGlsZHJlbiIsInB1c2giLCJfaW5pdFNweVRhcmdldEl0ZW1zIiwic2V0U3RhdGUiLCJfc3B5IiwiX3NldExpc3RJdGVtcyIsInRhcmdldHMiLCJlbGVtZW5zVmlld1N0YXRlIiwiX2dldEVsZW1zVmlld1N0YXRlIiwiY3VycmVudFN0YXR1c2VzIiwidmlld1N0YXR1c0xpc3QiLCJzY3JvbGxlZFBhc3QiLCJfdXBkYXRlIiwidGhyb3R0bGUiLCJldmVudCIsInN0b3BQcm9wYWdhdGlvbiIsInByZXZlbnREZWZhdWx0IiwiZG9jdW1lbnQiLCJnZXRFbGVtZW50QnlJZCIsInNjcm9sbEludG9WaWV3Iiwic2V0VGltZW91dCIsIndpbmRvdyIsImxvY2F0aW9uIiwiaGFzaCIsInJlc3VsdENoaWxkcmVuIiwiaSIsImhyZWYiLCJzcGxpdCIsIml0ZW0iLCJoYXNJblZpZXdBbHJlYWR5IiwiZWxlbXNJblZpZXciLCJlbGVtc091dFZpZXciLCJtYXgiLCJsZW5ndGgiLCJjdXJyZW50Q29udGVudCIsImlzSW5WaWV3IiwiX2lzSW5WaWV3IiwiaXNMYXN0SXRlbSIsImlzU2Nyb2xsZWQiLCJfaXNTY3JvbGxlZCIsImlzTGFzdFNob3J0SXRlbUF0Qm90dG9tIiwiX2lzQXRCb3R0b20iLCJwb3AiLCJmaWxsQXJyYXkiLCJpblZpZXciLCJvdXRWaWV3IiwiX2dldFNjcm9sbGVkUGFzdCIsImVsIiwicm9vdFJlY3QiLCJxdWVyeVNlbGVjdG9yIiwiZ2V0Qm91bmRpbmdDbGllbnRSZWN0IiwicmVjdCIsIndpbkgiLCJoZWlnaHQiLCJpbm5lckhlaWdodCIsInNjcm9sbFRvcCIsIl9nZXRTY3JvbGxEaW1lbnNpb24iLCJzY3JvbGxCb3R0b20iLCJlbFRvcCIsInRvcCIsImVsQm90dG9tIiwib2Zmc2V0SGVpZ2h0IiwiZG9jdW1lbnRFbGVtZW50IiwiYm9keSIsInBhcmVudE5vZGUiLCJzY3JvbGxIZWlnaHQiLCJzY3JvbGxlZFRvQm90dG9tIiwic29tZSIsImhhc0ZvdW5kSW5WaWV3Iiwic2Nyb2xsZWRQYXN0SXRlbXMiLCJwcmV2U3RhdHVzZXMiLCJpc0VxdWFsQXJyYXkiLCJpbmRleE9mIiwib2ZmRXZlbnQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25FdmVudCIsImFkZEV2ZW50TGlzdGVuZXIiLCJjb21wb25lbnREaWRNb3VudCIsImNvbXBvbmVudFdpbGxVbm1vdW50IiwiY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyIsIl9pbml0RnJvbVByb3BzIiwiX3NldFNjcm9sbFNlbGVjdE5hdiIsImN1cnJlbnRIYXNoIiwiaW5kZXhWaWV3IiwiY3VycmVudEluZGV4IiwicmVuZGVyIiwiY2xhc3NOYW1lIiwiVGFnQ29tcG9uZW50IiwiY291bnRlciIsImlkeCIsIkNoaWxkVGFnIiwidHlwZSIsImVsZW1lbnRJRCIsImNoaWxkQ2xhc3MiXSwibWFwcGluZ3MiOiI7O0FB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bEI7QUFDQSxZQUFNNkcsYUFBYXJJLFdBQVc7QUFDNUIsU0FBRSxHQUFHc0MsTUFBTWQsS0FBTixDQUFZc0csU0FBVyxFQUE1QixHQUFnQ3hGLE1BQU1kLEtBQU4sQ0FBWXNHLFNBQVosSUFBeUIsRUFEN0I7QUFFNUIsU0FBRSxHQUFHLEtBQUt0RyxLQUFMLENBQVdiLE1BQVEsRUFBeEIsR0FBNEJnQixZQUFZc0csR0FBWjtBQUZBLE9BQVgsQ0FBbkI7QUFJQSxXQUFLUixtQkFBTDtBQUNBLGFBQ0U7QUFBQyxnQkFBRDtBQUFBLHFCQUFlbkYsTUFBTWQsS0FBckIsSUFBNkIsV0FBWTZHLFVBQXpDLEVBQXNELEtBQU1MLFNBQTVELEVBQXdFLFNBQVUxRSxLQUFELElBQVcsS0FBS3RCLFdBQUwsQ0FBaUJzQixLQUFqQixFQUF3QjhFLFNBQXhCLENBQTVGO0FBQ0k5RixjQUFNZCxLQUFOLENBQVlXO0FBRGhCLE9BREY7QUFLRCxLQWhCYSxDQUFkOztBQWtCQSxXQUNFO0FBQUMsa0JBQUQ7QUFBQSxRQUFjLFdBQVkyRixTQUExQjtBQUNJakc7QUFESixLQURGO0FBS0Q7QUFoU29EIiwiZmlsZSI6IlNjcm9sbHNweS5qcyIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBSZWFjdCBmcm9tICdyZWFjdCdcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcydcbmltcG9ydCBjbGFzc05hbWVzIGZyb20gJ2NsYXNzbmFtZXMnXG5pbXBvcnQgSGVscGVycyBmcm9tICcuL2hlbHBlcnMnXG5cbmV4cG9ydCBkZWZhdWx0IGNsYXNzIFNjcm9sbHNweSBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIHN0YXRpYyBnZXQgcHJvcFR5cGVzKCkge1xuICAgIHJldHVybiB7XG4gICAgICB0YWc6IFByb3BUeXBlcy5vbmVPZlR5cGUoW1Byb3BUeXBlcy5zdHJpbmcsIFByb3BUeXBlcy5mdW5jXSksXG4gICAgICBjb21wb25lbnRDbGFzczogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIHNjcm9sbGVkUGFzdENsYXNzTmFtZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGFjdGl2ZTogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGxldmVsOiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgb2Zmc2V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgdGltZW91dDogUHJvcFR5cGVzLm51bWJlcixcbiAgICAgIHJvb3RFbDogUHJvcFR5cGVzLnN0cmluZyxcbiAgICAgIGFuaW1ldGU6IFByb3BUeXBlcy5vYmplY3QsXG4gICAgICBvblVwZGF0ZTogUHJvcFR5cGVzLmZ1bmNcbiAgICB9XG4gIH1cblxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wcyAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogJ3VsJyxcbiAgICAgIGNvbXBvbmVudENsYXNzOiAnJyxcbiAgICAgIGFjdGl2ZTogJ2FjdGl2ZScsXG4gICAgICBsZXZlbDogMSxcbiAgICAgIG9mZnNldDogMCxcbiAgICAgIHRpbWVvdXQ6IDUwMCxcbiAgICAgIGFuaW1ldGU6IHsgYmVoYXZpb3I6ICdzbW9vdGgnLCBibG9jazogJ3N0YXJ0JyB9LFxuICAgICAgb25VcGRhdGUoKSB7fSxcbiAgICB9XG4gIH1cblxuICBjb25zdHJ1Y3RvciAocHJvcHMpIHtcbiAgICBzdXBlcihwcm9wcylcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgdGFyZ2V0SXRlbXM6IFtdLFxuICAgICAgaW5WaWV3U3RhdGU6IFtdLFxuICAgICAgaXNTY3JvbGxlZFBhc3Q6IFtdLFxuICAgICAgaXRlbXM6IFtdXG4gICAgfVxuICAgIHRoaXMuX2hhbmRsZVNweSA9IHRoaXMuX2hhbmRsZVNweS5iaW5kKHRoaXMpXG4gICAgdGhpcy5nb1Njcm9sbFRhZyA9IHRoaXMuZ29TY3JvbGxUYWcuYmluZCh0aGlzKVxuICB9XG5cbiAgX2luaXRQcm9wcyAoKSB7XG4gICAgbGV0IGNoaWxkcmVuVGFnID0gW10sICB7IGNoaWxkcmVuIH0gID0gdGhpcy5wcm9wc1xuICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBsZXQgdG1wQ2hpbGQgPSB0aGlzLl9nZXRMZXZlbENoaWxkcmVuKGNoaWxkLnByb3BzKVxuICAgICAgaWYgKHRtcENoaWxkKSB7XG4gICAgICAgIGNoaWxkcmVuVGFnLnB1c2godG1wQ2hpbGQpXG4gICAgICB9XG4gICAgfSlcblxuICAgIGNvbnN0IHRhcmdldEl0ZW1zID0gdGhpcy5faW5pdFNweVRhcmdldEl0ZW1zKGNoaWxkcmVuVGFnKVxuICAgIHRoaXMuc2V0U3RhdGUoe1xuICAgICAgdGFyZ2V0SXRlbXMsXG4gICAgfSlcblxuICAgIHRoaXMuX3NweSh0YXJnZXRJdGVtcylcbiAgfVxuXG4gIF9zZXRMaXN0SXRlbXMgKCkge1xuICAgIGxldCBpdGVtcyA9IFtdLCAgeyBjaGlsZHJlbiB9ICA9IHRoaXMucHJvcHNcbiAgICBSZWFjdC5DaGlsZHJlbi5tYXAoY2hpbGRyZW4sIChjaGlsZCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgbGV0IHRtcENoaWxkID0gdGhpcy5fZ2V0TGV2ZWxDaGlsZHJlbihjaGlsZC5wcm9wcylcbiAgICAgIGlmICh0bXBDaGlsZCkge1xuICAgICAgICBpdGVtcy5wdXNoKHRtcENoaWxkKVxuICAgICAgfVxuICAgIH0pXG4gICAgdGhpcy5zZXRTdGF0ZSh7IGl0ZW1zIH0pXG4gIH1cblxuICBfc3B5ICh0YXJnZXRzKSB7XG4gICAgY29uc3QgZWxlbWVuc1ZpZXdTdGF0ZSA9IHRoaXMuX2dldEVsZW1zVmlld1N0YXRlKHRhcmdldHMpXG4gICAgY29uc3QgY3VycmVudFN0YXR1c2VzID0gdGhpcy5zdGF0ZS5pblZpZXdTdGF0ZVxuXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICBpblZpZXdTdGF0ZTogZWxlbWVuc1ZpZXdTdGF0ZS52aWV3U3RhdHVzTGlzdCxcbiAgICAgIGlzU2Nyb2xsZWRQYXN0OiBlbGVtZW5zVmlld1N0YXRlLnNjcm9sbGVkUGFzdFxuICAgIH0sICgpID0+IHtcbiAgICAgIHRoaXMuX3VwZGF0ZShjdXJyZW50U3RhdHVzZXMpXG4gICAgfSlcbiAgfVxuXG4gIF9oYW5kbGVTcHkgKCkge1xuICAgIEhlbHBlcnMudGhyb3R0bGUodGhpcy5fc3B5KCksIDEwMClcbiAgfVxuXG4gIGdvU2Nyb2xsVGFnKGV2ZW50LCB0YWcpIHtcbiAgICBldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXG4gICAgY29uc3QgeyBhbmltZXRlLCB0aW1lb3V0IH0gPSB0aGlzLnByb3BzXG4gICAgZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQodGFnKS5zY3JvbGxJbnRvVmlldyhhbmltZXRlKVxuXG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcjJyArIHRhZ1xuICAgIH0sIHRpbWVvdXQpO1xuICB9XG5cbiAgLy8gT0xERVJTXG4gIF9nZXRMZXZlbENoaWxkcmVuIChjaGlsZCkge1xuICAgIGxldCByZXN1bHRDaGlsZHJlbiA9IFtdLCB7IGxldmVsIH0gPSB0aGlzLnByb3BzXG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBsZXZlbDsgaSsrKSB7XG4gICAgICByZXN1bHRDaGlsZHJlbiA9IGNoaWxkLmNoaWxkcmVuLnByb3BzXG4gICAgfVxuICAgIGlmICghcmVzdWx0Q2hpbGRyZW4uaHJlZikge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIHJldHVybiByZXN1bHRDaGlsZHJlbi5ocmVmLnNwbGl0KCcjJylbMV1cbiAgfVxuXG4gIF9pbml0U3B5VGFyZ2V0SXRlbXMgKGl0ZW1zKSB7XG4gICAgcmV0dXJuIGl0ZW1zLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgcmV0dXJuIGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGl0ZW0pXG4gICAgfSlcbiAgfVxuXG4gIF9nZXRFbGVtc1ZpZXdTdGF0ZSAodGFyZ2V0cykge1xuICAgIGNvbnN0IHRhcmdldEl0ZW1zID0gdGFyZ2V0cyA/IHRhcmdldHMgOiB0aGlzLnN0YXRlLnRhcmdldEl0ZW1zXG4gICAgbGV0IGhhc0luVmlld0FscmVhZHkgPSBmYWxzZVxuICAgIGxldCBlbGVtc0luVmlldyA9IFtdXG4gICAgbGV0IGVsZW1zT3V0VmlldyA9IFtdXG4gICAgbGV0IHZpZXdTdGF0dXNMaXN0ID0gW11cblxuICAgIGZvciAobGV0IGkgPSAwLCBtYXggPSB0YXJnZXRJdGVtcy5sZW5ndGg7IGkgPCBtYXg7IGkrKykge1xuICAgICAgbGV0IGN1cnJlbnRDb250ZW50ID0gdGFyZ2V0SXRlbXNbaV1cbiAgICAgIGxldCBpc0luVmlldyA9IGhhc0luVmlld0FscmVhZHkgPyBmYWxzZSA6IHRoaXMuX2lzSW5WaWV3KGN1cnJlbnRDb250ZW50KVxuICAgICAgaWYgKGlzSW5WaWV3KSB7XG4gICAgICAgIGhhc0luVmlld0FscmVhZHkgPSB0cnVlXG4gICAgICAgIGVsZW1zSW5WaWV3LnB1c2goY3VycmVudENvbnRlbnQpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBlbGVtc091dFZpZXcucHVzaChjdXJyZW50Q29udGVudClcbiAgICAgIH1cblxuICAgICAgY29uc3QgaXNMYXN0SXRlbSA9IGkgPT09IG1heCAtIDFcbiAgICAgIGNvbnN0IGlzU2Nyb2xsZWQgPSB0aGlzLl9pc1Njcm9sbGVkKClcbiAgICAgIGNvbnN0IGlzTGFzdFNob3J0SXRlbUF0Qm90dG9tID0gdGhpcy5faXNBdEJvdHRvbSgpICYmIHRoaXMuX2lzSW5WaWV3KGN1cnJlbnRDb250ZW50KSAmJiAhaXNJblZpZXcgJiYgaXNMYXN0SXRlbSAmJiBpc1Njcm9sbGVkXG5cbiAgICAgIGlmIChpc0xhc3RTaG9ydEl0ZW1BdEJvdHRvbSkge1xuICAgICAgICBlbGVtc091dFZpZXcucG9wKClcbiAgICAgICAgZWxlbXNPdXRWaWV3LnB1c2goLi4uZWxlbXNJblZpZXcpXG4gICAgICAgIGVsZW1zSW5WaWV3ID0gW2N1cnJlbnRDb250ZW50XVxuICAgICAgICB2aWV3U3RhdHVzTGlzdCA9IEhlbHBlcnMuZmlsbEFycmF5KHZpZXdTdGF0dXNMaXN0LCBmYWxzZSlcbiAgICAgICAgaXNJblZpZXcgPSB0cnVlXG4gICAgICB9XG5cbiAgICAgIHZpZXdTdGF0dXNMaXN0LnB1c2goaXNJblZpZXcpXG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIGluVmlldzogZWxlbXNJblZpZXcsXG4gICAgICBvdXRWaWV3OiBlbGVtc091dFZpZXcsXG4gICAgICB2aWV3U3RhdHVzTGlzdCxcbiAgICAgIHNjcm9sbGVkUGFzdDogdGhpcy5wcm9wcy5zY3JvbGxlZFBhc3RDbGFzc05hbWUgJiYgdGhpcy5fZ2V0U2Nyb2xsZWRQYXN0KHZpZXdTdGF0dXNMaXN0KSxcbiAgICB9XG4gIH1cblxuICBfaXNJblZpZXcgKGVsKSB7XG4gICAgaWYgKCFlbCkgeyByZXR1cm4gZmFsc2UgfVxuICAgIGNvbnN0IHsgcm9vdEVsLCBvZmZzZXQgfSA9IHRoaXMucHJvcHNcbiAgICBsZXQgcm9vdFJlY3RcbiAgICBpZiAocm9vdEVsKSB7IHJvb3RSZWN0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290RWwpLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpIH1cblxuICAgIGNvbnN0IHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVxuICAgIGNvbnN0IHdpbkggPSByb290RWwgPyByb290UmVjdC5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBjb25zdCB7IHNjcm9sbFRvcCB9ID0gdGhpcy5fZ2V0U2Nyb2xsRGltZW5zaW9uKClcbiAgICBjb25zdCBzY3JvbGxCb3R0b20gPSBzY3JvbGxUb3AgKyB3aW5IXG4gICAgY29uc3QgZWxUb3AgPSByb290RWwgP1xuICAgICAgcmVjdC50b3AgKyBzY3JvbGxUb3AgLSByb290UmVjdC50b3AgKyBvZmZzZXRcbiAgICAgIDpcbiAgICAgIHJlY3QudG9wICsgc2Nyb2xsVG9wICsgb2Zmc2V0XG4gICAgY29uc3QgZWxCb3R0b20gPSBlbFRvcCArIGVsLm9mZnNldEhlaWdodFxuXG4gICAgcmV0dXJuIChlbFRvcCA8IHNjcm9sbEJvdHRvbSkgJiYgKGVsQm90dG9tID4gc2Nyb2xsVG9wKVxuICB9XG5cbiAgX2dldFNjcm9sbERpbWVuc2lvbiAoKSB7XG4gICAgY29uc3QgeyByb290RWwgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBzY3JvbGxUb3AgPSByb290RWwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RFbCkuc2Nyb2xsVG9wIDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3AgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbFRvcClcbiAgICBjb25zdCBzY3JvbGxIZWlnaHQgPSByb290RWwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RFbCkuc2Nyb2xsSGVpZ2h0IDogKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxIZWlnaHQgfHwgZG9jdW1lbnQuYm9keS5wYXJlbnROb2RlLnNjcm9sbEhlaWdodCB8fCBkb2N1bWVudC5ib2R5LnNjcm9sbEhlaWdodClcbiAgICByZXR1cm4geyBzY3JvbGxUb3AsIHNjcm9sbEhlaWdodCB9XG4gIH1cblxuICBfaXNBdEJvdHRvbSAoKSB7XG4gICAgY29uc3QgeyByb290RWwgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IH0gPSB0aGlzLl9nZXRTY3JvbGxEaW1lbnNpb24oKVxuICAgIGNvbnN0IHdpbkggPSByb290RWwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RFbCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkuaGVpZ2h0IDogd2luZG93LmlubmVySGVpZ2h0XG4gICAgY29uc3Qgc2Nyb2xsZWRUb0JvdHRvbSA9IChzY3JvbGxUb3AgKyB3aW5IKSA+PSBzY3JvbGxIZWlnaHRcbiAgICByZXR1cm4gc2Nyb2xsZWRUb0JvdHRvbVxuICB9XG5cbiAgX2lzU2Nyb2xsZWQgKCkge1xuICAgIHJldHVybiB0aGlzLl9nZXRTY3JvbGxEaW1lbnNpb24oKS5zY3JvbGxUb3AgPiAwXG4gIH1cblxuICBfZ2V0U2Nyb2xsZWRQYXN0ICh2aWV3U3RhdHVzTGlzdCkge1xuICAgIGlmICghdmlld1N0YXR1c0xpc3Quc29tZSgoaXRlbSkgPT4gaXRlbSkpIHsgcmV0dXJuIHZpZXdTdGF0dXNMaXN0IH1cbiAgICBsZXQgaGFzRm91bmRJblZpZXcgPSBmYWxzZVxuICAgIGNvbnN0IHNjcm9sbGVkUGFzdEl0ZW1zID0gdmlld1N0YXR1c0xpc3QubWFwKChpdGVtKSA9PiB7XG4gICAgICBpZiAoaXRlbSAmJiAhaGFzRm91bmRJblZpZXcpIHtcbiAgICAgICAgaGFzRm91bmRJblZpZXcgPSB0cnVlXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgcmV0dXJuICFoYXNGb3VuZEluVmlld1xuICAgIH0pXG4gICAgcmV0dXJuIHNjcm9sbGVkUGFzdEl0ZW1zXG4gIH1cblxuICBfdXBkYXRlIChwcmV2U3RhdHVzZXMpIHtcbiAgICBjb25zdCB7IGluVmlld1N0YXRlLCB0YXJnZXRJdGVtcyB9ID0gdGhpcy5zdGF0ZVxuICAgIGlmIChIZWxwZXJzLmlzRXF1YWxBcnJheShpblZpZXdTdGF0ZSwgcHJldlN0YXR1c2VzKSkgeyByZXR1cm4gfVxuICAgIHRoaXMucHJvcHMub25VcGRhdGUodGFyZ2V0SXRlbXNbaW5WaWV3U3RhdGUuaW5kZXhPZih0cnVlKV0pXG4gIH1cblxuICBvZmZFdmVudCgpIHtcbiAgICBsZXQgeyByb290RWwgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBlbCA9IHJvb3RFbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsKSA6IHdpbmRvd1xuICAgIGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVNweSlcbiAgfVxuXG4gIG9uRXZlbnQoKSB7XG4gICAgbGV0IHsgcm9vdEVsIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgZWwgPSByb290RWwgPyBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RFbCkgOiB3aW5kb3dcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdzY3JvbGwnLCB0aGlzLl9oYW5kbGVTcHkpXG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCAoKSB7XG4gICAgdGhpcy5faW5pdFByb3BzKClcbiAgICB0aGlzLl9zZXRMaXN0SXRlbXMoKVxuICAgIHRoaXMub25FdmVudCgpXG4gIH1cblxuICBjb21wb25lbnRXaWxsVW5tb3VudCAoKSB7XG4gICAgdGhpcy5vZmZFdmVudCgpXG4gIH1cblxuICBjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzICgpIHtcbiAgICB0aGlzLl9pbml0RnJvbVByb3BzKClcbiAgfVxuXG4gIF9zZXRTY3JvbGxTZWxlY3ROYXYoKSB7XG4gICAgdGhpcy5vbkV2ZW50KClcbiAgICBjb25zdCB7IGluVmlld1N0YXRlLCBpdGVtcyB9ID0gdGhpcy5zdGF0ZVxuICAgIGlmKCBpblZpZXdTdGF0ZS5pbmRleE9mKHRydWUpICE9PSAtMSApIHtcbiAgICAgIGxldCBoYXNoLCBjdXJyZW50SGFzaCwgaW5kZXhWaWV3ID0gaW5WaWV3U3RhdGUuaW5kZXhPZih0cnVlKVxuICAgICAgaGFzaCA9IGl0ZW1zW2luZGV4Vmlld11cbiAgICAgIGN1cnJlbnRIYXNoID0gd2luZG93LmxvY2F0aW9uLmhhc2guc3BsaXQoJyMnKVsxXVxuICAgICAgbGV0IGN1cnJlbnRJbmRleCA9IGl0ZW1zLmluZGV4T2YoY3VycmVudEhhc2gpXG4gICAgICBpZiAoIGhhc2ggKSB7XG4gICAgICAgIGlmKCBjdXJyZW50SW5kZXggPCBpbmRleFZpZXcgKSB7XG4gICAgICAgICAgd2luZG93LmxvY2F0aW9uLmhhc2ggPSAnIycgKyBoYXNoXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgY2xhc3NOYW1lID0gJycsIHRhZyB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgaW5WaWV3U3RhdGUgfSA9IHRoaXMuc3RhdGVcbiAgICBjb25zdCBUYWdDb21wb25lbnQgPSB0YWdcbiAgICBsZXQgY291bnRlciA9IDBcbiAgICBjb25zdCBpdGVtcyA9IFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkLCBpZHgpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGNvbnN0IENoaWxkVGFnID0gY2hpbGQudHlwZVxuICAgICAgY29uc3QgZWxlbWVudElEID0gdGhpcy5fZ2V0TGV2ZWxDaGlsZHJlbihjaGlsZC5wcm9wcylcbiAgICAgIGNvbnN0IGNoaWxkQ2xhc3MgPSBjbGFzc05hbWVzKHtcbiAgICAgICAgW2AkeyBjaGlsZC5wcm9wcy5jbGFzc05hbWUgfWBdOiBjaGlsZC5wcm9wcy5jbGFzc05hbWUgfHwgJycsXG4gICAgICAgIFtgJHsgdGhpcy5wcm9wcy5hY3RpdmUgfWBdOiBpblZpZXdTdGF0ZVtpZHhdXG4gICAgICB9KVxuICAgICAgdGhpcy5fc2V0U2Nyb2xsU2VsZWN0TmF2KClcbiAgICAgIHJldHVybiAoXG4gICAgICAgIDxDaGlsZFRhZyB7IC4uLmNoaWxkLnByb3BzIH0gY2xhc3NOYW1lPXsgY2hpbGRDbGFzcyB9IGtleT17IGNvdW50ZXIrKyB9IG9uQ2xpY2s9eyhldmVudCkgPT4gdGhpcy5nb1Njcm9sbFRhZyhldmVudCwgZWxlbWVudElEKX0gPlxuICAgICAgICAgIHsgY2hpbGQucHJvcHMuY2hpbGRyZW4gfVxuICAgICAgICA8L0NoaWxkVGFnPlxuICAgICAgKVxuICAgIH0pXG5cbiAgICByZXR1cm4gKFxuICAgICAgPFRhZ0NvbXBvbmVudCBjbGFzc05hbWU9eyBjbGFzc05hbWUgfT5cbiAgICAgICAgeyBpdGVtcyB9XG4gICAgICA8L1RhZ0NvbXBvbmVudD5cbiAgICApXG4gIH1cbn1cbiJdfQ==