var _extends = Object.assign || function (target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i]; for (var key in source) { if (Object.prototype.hasOwnProperty.call(source, key)) { target[key] = source[key]; } } } return target; };

import React from 'react';
import PropTypes from 'prop-types';
import classNames from 'classnames';
import Helpers from './helpers';

export default class Scrollspy extends React.Component {
  static get propTypes() {
    return {
      tag: PropTypes.oneOfType([PropTypes.string, PropTypes.func]),
      componentClass: PropTypes.string,
      scrolledPastClassName: PropTypes.string,
      active: PropTypes.string,
      level: PropTypes.number,
      offset: PropTypes.number,
      timeout: PropTypes.number,
      rootEl: PropTypes.string,
      animete: PropTypes.object,
      onUpdate: PropTypes.func
    };
  }

  static get defaultProps() {
    return {
      tag: 'ul',
      componentClass: '',
      active: 'active',
      level: 1,
      offset: 0,
      timeout: 500,
      animete: { behavior: 'smooth', block: 'start' },
      onUpdate() {}
    };
  }

  constructor(props) {
    super(props);
    this.state = {
      targetItems: [],
      inViewState: [],
      isScrolledPast: [],
      items: []
    };
    this._handleSpy = this._handleSpy.bind(this);
    this.goScrollTag = this.goScrollTag.bind(this);
  }

  _initProps() {
    let childrenTag = [],
        { children } = this.props;
    React.Children.map(children, child => {
      if (!child) {
        return null;
      }
      let tmpChild = this._getLevelChildren(child.props);
      if (tmpChild) {
        childrenTag.push(tmpChild);
      }
    });

    const targetItems = this._initSpyTargetItems(childrenTag);
    this.setState({
      targetItems
    });

    this._spy(targetItems);
  }

  _setListItems() {
    let items = [],
        { children } = this.props;
    React.Children.map(children, child => {
      if (!child) {
        return null;
      }
      let tmpChild = this._getLevelChildren(child.props);
      if (tmpChild) {
        items.push(tmpChild);
      }
    });
    this.setState({ items });
  }

  _spy(targets) {
    const elemensViewState = this._getElemsViewState(targets);
    const currentStatuses = this.state.inViewState;

    this.setState({
      inViewState: elemensViewState.viewStatusList,
      isScrolledPast: elemensViewState.scrolledPast
    }, () => {
      this._update(currentStatuses);
    });
  }

  _handleSpy() {
    Helpers.throttle(this._spy(), 100);
  }

  goScrollTag(event, tag) {
    event.stopPropagation();
    event.preventDefault();

    const { animete, timeout } = this.props;
    document.getElementById(tag).scrollIntoView(animete);

    setTimeout(() => {
      window.location.hash = '#' + tag;
    }, timeout);
  }

  // OLDERS
  _getLevelChildren(child) {
    let resultChildren = [],
        { level } = this.props;
    for (let i = 0; i < level; i++) {
      resultChildren = child.children.props;
    }
    if (!resultChildren.href) {
      return;
    }
    return resultChildren.href.split('#')[1];
  }

  _initSpyTargetItems(items) {
    return items.map(item => {
      return document.getElementById(item);
    });
  }

  _getElemsViewState(targets) {
    const targetItems = targets ? targets : this.state.targetItems;
    let hasInViewAlready = false;
    let elemsInView = [];
    let elemsOutView = [];
    let viewStatusList = [];

    for (let i = 0, max = targetItems.length; i < max; i++) {
      let currentContent = targetItems[i];
      let isInView = hasInViewAlready ? false : this._isInView(currentContent);
      if (isInView) {
        hasInViewAlready = true;
        elemsInView.push(currentContent);
      } else {
        elemsOutView.push(currentContent);
      }

      const isLastItem = i === max - 1;
      const isScrolled = this._isScrolled();
      const isLastShortItemAtBottom = this._isAtBottom() && this._isInView(currentContent) && !isInView && isLastItem && isScrolled;

      if (isLastShortItemAtBottom) {
        elemsOutView.pop();
        elemsOutView.push(...elemsInView);
        elemsInView = [currentContent];
        viewStatusList = Helpers.fillArray(viewStatusList, false);
        isInView = true;
      }

      viewStatusList.push(isInView);
    }

    return {
      inView: elemsInView,
      outView: elemsOutView,
      viewStatusList,
      scrolledPast: this.props.scrolledPastClassName && this._getScrolledPast(viewStatusList)
    };
  }

  _isInView(el) {
    if (!el) {
      return false;
    }
    const { rootEl, offset } = this.props;
    let rootRect;
    if (rootEl) {
      rootRect = document.querySelector(rootEl).getBoundingClientRect();
    }

    const rect = el.getBoundingClientRect();
    const winH = rootEl ? rootRect.height : window.innerHeight;
    const { scrollTop } = this._getScrollDimension();
    const scrollBottom = scrollTop + winH;
    const elTop = rootEl ? rect.top + scrollTop - rootRect.top + offset : rect.top + scrollTop + offset;
    const elBottom = elTop + el.offsetHeight;

    return elTop < scrollBottom && elBottom > scrollTop;
  }

  _getScrollDimension() {
    const { rootEl } = this.props;
    const scrollTop = rootEl ? document.querySelector(rootEl).scrollTop : document.documentElement.scrollTop || document.body.parentNode.scrollTop || document.body.scrollTop;
    const scrollHeight = rootEl ? document.querySelector(rootEl).scrollHeight : document.documentElement.scrollHeight || document.body.parentNode.scrollHeight || document.body.scrollHeight;
    return { scrollTop, scrollHeight };
  }

  _isAtBottom() {
    const { rootEl } = this.props;
    const { scrollTop, scrollHeight } = this._getScrollDimension();
    const winH = rootEl ? document.querySelector(rootEl).getBoundingClientRect().height : window.innerHeight;
    const scrolledToBottom = scrollTop + winH >= scrollHeight;
    return scrolledToBottom;
  }

  _isScrolled() {
    return this._getScrollDimension().scrollTop > 0;
  }

  _getScrolledPast(viewStatusList) {
    if (!viewStatusList.some(item => item)) {
      return viewStatusList;
    }
    let hasFoundInView = false;
    const scrolledPastItems = viewStatusList.map(item => {
      if (item && !hasFoundInView) {
        hasFoundInView = true;
        return false;
      }
      return !hasFoundInView;
    });
    return scrolledPastItems;
  }

  _update(prevStatuses) {
    const { inViewState, targetItems } = this.state;
    if (Helpers.isEqualArray(inViewState, prevStatuses)) {
      return;
    }
    this.props.onUpdate(targetItems[inViewState.indexOf(true)]);
  }

  offEvent() {
    let { rootEl } = this.props;
    const el = rootEl ? document.querySelector(rootEl) : window;
    el.removeEventListener('scroll', this._handleSpy);
  }

  onEvent() {
    let { rootEl } = this.props;
    const el = rootEl ? document.querySelector(rootEl) : window;
    el.addEventListener('scroll', this._handleSpy);
  }

  componentDidMount() {
    this._initProps();
    this._setListItems();
    this.onEvent();
  }

  componentWillUnmount() {
    this.offEvent();
  }

  componentWillReceiveProps() {
    this._initFromProps();
  }

  _setScrollSelectNav() {
    this.onEvent();
    const { inViewState, items } = this.state;
    if (inViewState.indexOf(true) !== -1) {
      let hash,
          currentHash,
          indexView = inViewState.indexOf(true);
      hash = items[indexView];
      currentHash = window.location.hash.split('#')[1];
      let currentIndex = items.indexOf(currentHash);
      if (hash) {
        if (currentIndex < indexView) {
          window.location.hash = '#' + hash;
        }
      }
    }
  }

  render() {
    const { children, className = '', tag } = this.props;
    const { inViewState } = this.state;
    const TagComponent = tag;
    let counter = 0;
    const items = React.Children.map(children, (child, idx) => {
      if (!child) {
        return null;
      }
      const ChildTag = child.type;
      const elementID = this._getLevelChildren(child.props);
      const childClass = classNames({
        [`${child.props.className}`]: child.props.className || '',
        [`${this.props.active}`]: inViewState[idx]
      });
      this._setScrollSelectNav();
      return React.createElement(
        ChildTag,
        _extends({}, child.props, { className: childClass, key: counter++, onClick: event => this.goScrollTag(event, elementID) }),
        child.props.children
      );
    });

    return React.createElement(
      TagComponent,
      { className: className },
      items
    );
  }
}
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9saWIvY29tcG9uZW50cy9TY3JvbGxzcHkuanMiXSwibmFtZXMiOlsiUmVhY3QiLCJQcm9wVHlwZXMiLCJjbGFzc05hbWVzIiwiSGVscGVycyIsIlNjcm9sbHNweSIsIkNvbXBvbmVudCIsInByb3BUeXBlcyIsInRhZyIsIm9uZU9mVHlwZSIsInN0cmluZyIsImZ1bmMiLCJjb21wb25lbnRDbGFzcyIsInNjcm9sbGVkUGFzdENsYXNzTmFtZSIsImFjdGl2ZSIsImxldmVsIiwibnVtYmVyIiwib2Zmc2V0IiwidGltZW91dCIsInJvb3RFbCIsImFuaW1ldGUiLCJvYmplY3QiLCJvblVwZGF0ZSIsImRlZmF1bHRQcm9wcyIsImJlaGF2aW9yIiwiYmxvY2siLCJjb25zdHJ1Y3RvciIsInByb3BzIiwic3RhdGUiLCJ0YXJnZXRJdGVtcyIsImluVmlld1N0YXRlIiwiaXNTY3JvbGxlZFBhc3QiLCJpdGVtcyIsIl9oYW5kbGVTcHkiLCJiaW5kIiwiZ29TY3JvbGxUYWciLCJfaW5pdFByb3BzIiwiY2hpbGRyZW5UYWciLCJjaGlsZHJlbiIsIkNoaWxkcmVuIiwibWFwIiwiY2hpbGQiLCJ0bXBDaGlsZCIsIl9nZXRMZXZlbENoaWxkcmVuIiwicHVzaCIsIl9pbml0U3B5VGFyZ2V0SXRlbXMiLCJzZXRTdGF0ZSIsIl9zcHkiLCJfc2V0TGlzdEl0ZW1zIiwidGFyZ2V0cyIsImVsZW1lbnNWaWV3U3RhdGUiLCJfZ2V0RWxlbXNWaWV3U3RhdGUiLCJjdXJyZW50U3RhdHVzZXMiLCJ2aWV3U3RhdHVzTGlzdCIsInNjcm9sbGVkUGFzdCIsIl91cGRhdGUiLCJ0aHJvdHRsZSIsImV2ZW50Iiwic3RvcFByb3BhZ2F0aW9uIiwicHJldmVudERlZmF1bHQiLCJkb2N1bWVudCIsImdldEVsZW1lbnRCeUlkIiwic2Nyb2xsSW50b1ZpZXciLCJzZXRUaW1lb3V0Iiwid2luZG93IiwibG9jYXRpb24iLCJoYXNoIiwicmVzdWx0Q2hpbGRyZW4iLCJpIiwiaHJlZiIsInNwbGl0IiwiaXRlbSIsImhhc0luVmlld0FscmVhZHkiLCJlbGVtc0luVmlldyIsImVsZW1zT3V0VmlldyIsIm1heCIsImxlbmd0aCIsImN1cnJlbnRDb250ZW50IiwiaXNJblZpZXciLCJfaXNJblZpZXciLCJpc0xhc3RJdGVtIiwiaXNTY3JvbGxlZCIsIl9pc1Njcm9sbGVkIiwiaXNMYXN0U2hvcnRJdGVtQXRCb3R0b20iLCJfaXNBdEJvdHRvbSIsInBvcCIsImZpbGxBcnJheSIsImluVmlldyIsIm91dFZpZXciLCJfZ2V0U2Nyb2xsZWRQYXN0IiwiZWwiLCJyb290UmVjdCIsInF1ZXJ5U2VsZWN0b3IiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJyZWN0Iiwid2luSCIsImhlaWdodCIsImlubmVySGVpZ2h0Iiwic2Nyb2xsVG9wIiwiX2dldFNjcm9sbERpbWVuc2lvbiIsInNjcm9sbEJvdHRvbSIsImVsVG9wIiwidG9wIiwiZWxCb3R0b20iLCJvZmZzZXRIZWlnaHQiLCJkb2N1bWVudEVsZW1lbnQiLCJib2R5IiwicGFyZW50Tm9kZSIsInNjcm9sbEhlaWdodCIsInNjcm9sbGVkVG9Cb3R0b20iLCJzb21lIiwiaGFzRm91bmRJblZpZXciLCJzY3JvbGxlZFBhc3RJdGVtcyIsInByZXZTdGF0dXNlcyIsImlzRXF1YWxBcnJheSIsImluZGV4T2YiLCJvZmZFdmVudCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJvbkV2ZW50IiwiYWRkRXZlbnRMaXN0ZW5lciIsImNvbXBvbmVudERpZE1vdW50IiwiY29tcG9uZW50V2lsbFVubW91bnQiLCJjb21wb25lbnRXaWxsUmVjZWl2ZVByb3BzIiwiX2luaXRGcm9tUHJvcHMiLCJfc2V0U2Nyb2xsU2VsZWN0TmF2IiwiY3VycmVudEhhc2giLCJpbmRleFZpZXciLCJjdXJyZW50SW5kZXgiLCJyZW5kZXIiLCJjbGFzc05hbWUiLCJUYWdDb21wb25lbnQiLCJjb3VudGVyIiwiaWR4IiwiQ2hpbGRUYWciLCJ0eXBlIiwiZWxlbWVudElEIiwiY2hpbGRDbGFzcyJdLCJt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QUFNZCxLQUE3QixDQUFsQjtBQUNBLFlBQU02RyxhQUFhckksV0FBVztBQUM1QixTQUFFLEdBQUdzQyxNQUFNZCxLQUFOLENBQVlzRyxTQUFXLEVBQTVCLEdBQWdDeEYsTUFBTWQsS0FBTixDQUFZc0csU0FBWixJQUF5QixFQUQ3QjtBQUU1QixTQUFFLEdBQUcsS0FBS3RHLEtBQUwsQ0FBV2IsTUFBUSxFQUF4QixHQUE0QmdCLFlBQVlzRyxHQUFaO0FBRkEsT0FBWCxDQUFuQjtBQUlBLFdBQUtSLG1CQUFMO0FBQ0EsYUFDRTtBQUFDLGdCQUFEO0FBQUEscUJBQWVuRixNQUFNZCxLQUFyQixJQUE2QixXQUFZNkcsVUFBekMsRUFBc0QsS0FBTUwsU0FBNUQsRUFBd0UsU0FBVTFFLEtBQUQsSUFBVyxLQUFLdEIsV0FBTCxDQUFpQnNCLEtBQWpCLEVBQXdCOEUsU0FBeEIsQ0FBNUY7QUFDSTlGLGNBQU1kLEtBQU4sQ0FBWVc7QUFEaEIsT0FERjtBQUtELEtBaEJhLENBQWQ7O0FBa0JBLFdBQ0U7QUFBQyxrQkFBRDtBQUFBLFFBQWMsV0FBWTJGLFNBQTFCO0FBQ0lqRztBQURKLEtBREY7QUFLRDtBQWhTb0QiLCJmaWxlIjoiU2Nyb2xsc3B5LmpzIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IFJlYWN0IGZyb20gJ3JlYWN0J1xuaW1wb3J0IFByb3BUeXBlcyBmcm9tICdwcm9wLXR5cGVzJ1xuaW1wb3J0IGNsYXNzTmFtZXMgZnJvbSAnY2xhc3NuYW1lcydcbmltcG9ydCBIZWxwZXJzIGZyb20gJy4vaGVscGVycydcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgU2Nyb2xsc3B5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgc3RhdGljIGdldCBwcm9wVHlwZXMoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHRhZzogUHJvcFR5cGVzLm9uZU9mVHlwZShbUHJvcFR5cGVzLnN0cmluZywgUHJvcFR5cGVzLmZ1bmNdKSxcbiAgICAgIGNvbXBvbmVudENsYXNzOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgc2Nyb2xsZWRQYXN0Q2xhc3NOYW1lOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYWN0aXZlOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgbGV2ZWw6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICBvZmZzZXQ6IFByb3BUeXBlcy5udW1iZXIsXG4gICAgICB0aW1lb3V0OiBQcm9wVHlwZXMubnVtYmVyLFxuICAgICAgcm9vdEVsOiBQcm9wVHlwZXMuc3RyaW5nLFxuICAgICAgYW5pbWV0ZTogUHJvcFR5cGVzLm9iamVjdCxcbiAgICAgIG9uVXBkYXRlOiBQcm9wVHlwZXMuZnVuY1xuICAgIH1cbiAgfVxuXG4gIHN0YXRpYyBnZXQgZGVmYXVsdFByb3BzICgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdGFnOiAndWwnLFxuICAgICAgY29tcG9uZW50Q2xhc3M6ICcnLFxuICAgICAgYWN0aXZlOiAnYWN0aXZlJyxcbiAgICAgIGxldmVsOiAxLFxuICAgICAgb2Zmc2V0OiAwLFxuICAgICAgdGltZW91dDogNTAwLFxuICAgICAgYW5pbWV0ZTogeyBiZWhhdmlvcjogJ3Ntb290aCcsIGJsb2NrOiAnc3RhcnQnIH0sXG4gICAgICBvblVwZGF0ZSgpIHt9LFxuICAgIH1cbiAgfVxuXG4gIGNvbnN0cnVjdG9yIChwcm9wcykge1xuICAgIHN1cGVyKHByb3BzKVxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICB0YXJnZXRJdGVtczogW10sXG4gICAgICBpblZpZXdTdGF0ZTogW10sXG4gICAgICBpc1Njcm9sbGVkUGFzdDogW10sXG4gICAgICBpdGVtczogW11cbiAgICB9XG4gICAgdGhpcy5faGFuZGxlU3B5ID0gdGhpcy5faGFuZGxlU3B5LmJpbmQodGhpcylcbiAgICB0aGlzLmdvU2Nyb2xsVGFnID0gdGhpcy5nb1Njcm9sbFRhZy5iaW5kKHRoaXMpXG4gIH1cblxuICBfaW5pdFByb3BzICgpIHtcbiAgICBsZXQgY2hpbGRyZW5UYWcgPSBbXSwgIHsgY2hpbGRyZW4gfSAgPSB0aGlzLnByb3BzXG4gICAgUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHtcbiAgICAgICAgcmV0dXJuIG51bGxcbiAgICAgIH1cbiAgICAgIGxldCB0bXBDaGlsZCA9IHRoaXMuX2dldExldmVsQ2hpbGRyZW4oY2hpbGQucHJvcHMpXG4gICAgICBpZiAodG1wQ2hpbGQpIHtcbiAgICAgICAgY2hpbGRyZW5UYWcucHVzaCh0bXBDaGlsZClcbiAgICAgIH1cbiAgICB9KVxuXG4gICAgY29uc3QgdGFyZ2V0SXRlbXMgPSB0aGlzLl9pbml0U3B5VGFyZ2V0SXRlbXMoY2hpbGRyZW5UYWcpXG4gICAgdGhpcy5zZXRTdGF0ZSh7XG4gICAgICB0YXJnZXRJdGVtcyxcbiAgICB9KVxuXG4gICAgdGhpcy5fc3B5KHRhcmdldEl0ZW1zKVxuICB9XG5cbiAgX3NldExpc3RJdGVtcyAoKSB7XG4gICAgbGV0IGl0ZW1zID0gW10sICB7IGNoaWxkcmVuIH0gID0gdGhpcy5wcm9wc1xuICAgIFJlYWN0LkNoaWxkcmVuLm1hcChjaGlsZHJlbiwgKGNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkKSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBsZXQgdG1wQ2hpbGQgPSB0aGlzLl9nZXRMZXZlbENoaWxkcmVuKGNoaWxkLnByb3BzKVxuICAgICAgaWYgKHRtcENoaWxkKSB7XG4gICAgICAgIGl0ZW1zLnB1c2godG1wQ2hpbGQpXG4gICAgICB9XG4gICAgfSlcbiAgICB0aGlzLnNldFN0YXRlKHsgaXRlbXMgfSlcbiAgfVxuXG4gIF9zcHkgKHRhcmdldHMpIHtcbiAgICBjb25zdCBlbGVtZW5zVmlld1N0YXRlID0gdGhpcy5fZ2V0RWxlbXNWaWV3U3RhdGUodGFyZ2V0cylcbiAgICBjb25zdCBjdXJyZW50U3RhdHVzZXMgPSB0aGlzLnN0YXRlLmluVmlld1N0YXRlXG5cbiAgICB0aGlzLnNldFN0YXRlKHtcbiAgICAgIGluVmlld1N0YXRlOiBlbGVtZW5zVmlld1N0YXRlLnZpZXdTdGF0dXNMaXN0LFxuICAgICAgaXNTY3JvbGxlZFBhc3Q6IGVsZW1lbnNWaWV3U3RhdGUuc2Nyb2xsZWRQYXN0XG4gICAgfSwgKCkgPT4ge1xuICAgICAgdGhpcy5fdXBkYXRlKGN1cnJlbnRTdGF0dXNlcylcbiAgICB9KVxuICB9XG5cbiAgX2hhbmRsZVNweSAoKSB7XG4gICAgSGVscGVycy50aHJvdHRsZSh0aGlzLl9zcHkoKSwgMTAwKVxuICB9XG5cbiAgZ29TY3JvbGxUYWcoZXZlbnQsIHRhZykge1xuICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cbiAgICBjb25zdCB7IGFuaW1ldGUsIHRpbWVvdXQgfSA9IHRoaXMucHJvcHNcbiAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCh0YWcpLnNjcm9sbEludG9WaWV3KGFuaW1ldGUpXG5cbiAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHdpbmRvdy5sb2NhdGlvbi5oYXNoID0gJyMnICsgdGFnXG4gICAgfSwgdGltZW91dCk7XG4gIH1cblxuICAvLyBPTERFUlNcbiAgX2dldExldmVsQ2hpbGRyZW4gKGNoaWxkKSB7XG4gICAgbGV0IHJlc3VsdENoaWxkcmVuID0gW10sIHsgbGV2ZWwgfSA9IHRoaXMucHJvcHNcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGxldmVsOyBpKyspIHtcbiAgICAgIHJlc3VsdENoaWxkcmVuID0gY2hpbGQuY2hpbGRyZW4ucHJvcHNcbiAgICB9XG4gICAgaWYgKCFyZXN1bHRDaGlsZHJlbi5ocmVmKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdENoaWxkcmVuLmhyZWYuc3BsaXQoJyMnKVsxXVxuICB9XG5cbiAgX2luaXRTcHlUYXJnZXRJdGVtcyAoaXRlbXMpIHtcbiAgICByZXR1cm4gaXRlbXMubWFwKChpdGVtKSA9PiB7XG4gICAgICByZXR1cm4gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoaXRlbSlcbiAgICB9KVxuICB9XG5cbiAgX2dldEVsZW1zVmlld1N0YXRlICh0YXJnZXRzKSB7XG4gICAgY29uc3QgdGFyZ2V0SXRlbXMgPSB0YXJnZXRzID8gdGFyZ2V0cyA6IHRoaXMuc3RhdGUudGFyZ2V0SXRlbXNcbiAgICBsZXQgaGFzSW5WaWV3QWxyZWFkeSA9IGZhbHNlXG4gICAgbGV0IGVsZW1zSW5WaWV3ID0gW11cbiAgICBsZXQgZWxlbXNPdXRWaWV3ID0gW11cbiAgICBsZXQgdmlld1N0YXR1c0xpc3QgPSBbXVxuXG4gICAgZm9yIChsZXQgaSA9IDAsIG1heCA9IHRhcmdldEl0ZW1zLmxlbmd0aDsgaSA8IG1heDsgaSsrKSB7XG4gICAgICBsZXQgY3VycmVudENvbnRlbnQgPSB0YXJnZXRJdGVtc1tpXVxuICAgICAgbGV0IGlzSW5WaWV3ID0gaGFzSW5WaWV3QWxyZWFkeSA/IGZhbHNlIDogdGhpcy5faXNJblZpZXcoY3VycmVudENvbnRlbnQpXG4gICAgICBpZiAoaXNJblZpZXcpIHtcbiAgICAgICAgaGFzSW5WaWV3QWxyZWFkeSA9IHRydWVcbiAgICAgICAgZWxlbXNJblZpZXcucHVzaChjdXJyZW50Q29udGVudClcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1zT3V0Vmlldy5wdXNoKGN1cnJlbnRDb250ZW50KVxuICAgICAgfVxuXG4gICAgICBjb25zdCBpc0xhc3RJdGVtID0gaSA9PT0gbWF4IC0gMVxuICAgICAgY29uc3QgaXNTY3JvbGxlZCA9IHRoaXMuX2lzU2Nyb2xsZWQoKVxuICAgICAgY29uc3QgaXNMYXN0U2hvcnRJdGVtQXRCb3R0b20gPSB0aGlzLl9pc0F0Qm90dG9tKCkgJiYgdGhpcy5faXNJblZpZXcoY3VycmVudENvbnRlbnQpICYmICFpc0luVmlldyAmJiBpc0xhc3RJdGVtICYmIGlzU2Nyb2xsZWRcblxuICAgICAgaWYgKGlzTGFzdFNob3J0SXRlbUF0Qm90dG9tKSB7XG4gICAgICAgIGVsZW1zT3V0Vmlldy5wb3AoKVxuICAgICAgICBlbGVtc091dFZpZXcucHVzaCguLi5lbGVtc0luVmlldylcbiAgICAgICAgZWxlbXNJblZpZXcgPSBbY3VycmVudENvbnRlbnRdXG4gICAgICAgIHZpZXdTdGF0dXNMaXN0ID0gSGVscGVycy5maWxsQXJyYXkodmlld1N0YXR1c0xpc3QsIGZhbHNlKVxuICAgICAgICBpc0luVmlldyA9IHRydWVcbiAgICAgIH1cblxuICAgICAgdmlld1N0YXR1c0xpc3QucHVzaChpc0luVmlldylcbiAgICB9XG5cbiAgICByZXR1cm4ge1xuICAgICAgaW5WaWV3OiBlbGVtc0luVmlldyxcbiAgICAgIG91dFZpZXc6IGVsZW1zT3V0VmlldyxcbiAgICAgIHZpZXdTdGF0dXNMaXN0LFxuICAgICAgc2Nyb2xsZWRQYXN0OiB0aGlzLnByb3BzLnNjcm9sbGVkUGFzdENsYXNzTmFtZSAmJiB0aGlzLl9nZXRTY3JvbGxlZFBhc3Qodmlld1N0YXR1c0xpc3QpLFxuICAgIH1cbiAgfVxuXG4gIF9pc0luVmlldyAoZWwpIHtcbiAgICBpZiAoIWVsKSB7IHJldHVybiBmYWxzZSB9XG4gICAgY29uc3QgeyByb290RWwsIG9mZnNldCB9ID0gdGhpcy5wcm9wc1xuICAgIGxldCByb290UmVjdFxuICAgIGlmIChyb290RWwpIHsgcm9vdFJlY3QgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKHJvb3RFbCkuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCkgfVxuXG4gICAgY29uc3QgcmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpXG4gICAgY29uc3Qgd2luSCA9IHJvb3RFbCA/IHJvb3RSZWN0LmhlaWdodCA6IHdpbmRvdy5pbm5lckhlaWdodFxuICAgIGNvbnN0IHsgc2Nyb2xsVG9wIH0gPSB0aGlzLl9nZXRTY3JvbGxEaW1lbnNpb24oKVxuICAgIGNvbnN0IHNjcm9sbEJvdHRvbSA9IHNjcm9sbFRvcCArIHdpbkhcbiAgICBjb25zdCBlbFRvcCA9IHJvb3RFbCA/XG4gICAgICByZWN0LnRvcCArIHNjcm9sbFRvcCAtIHJvb3RSZWN0LnRvcCArIG9mZnNldFxuICAgICAgOlxuICAgICAgcmVjdC50b3AgKyBzY3JvbGxUb3AgKyBvZmZzZXRcbiAgICBjb25zdCBlbEJvdHRvbSA9IGVsVG9wICsgZWwub2Zmc2V0SGVpZ2h0XG5cbiAgICByZXR1cm4gKGVsVG9wIDwgc2Nyb2xsQm90dG9tKSAmJiAoZWxCb3R0b20gPiBzY3JvbGxUb3ApXG4gIH1cblxuICBfZ2V0U2Nyb2xsRGltZW5zaW9uICgpIHtcbiAgICBjb25zdCB7IHJvb3RFbCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHNjcm9sbFRvcCA9IHJvb3RFbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsKS5zY3JvbGxUb3AgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsVG9wIHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsVG9wKVxuICAgIGNvbnN0IHNjcm9sbEhlaWdodCA9IHJvb3RFbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsKS5zY3JvbGxIZWlnaHQgOiAoZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbEhlaWdodCB8fCBkb2N1bWVudC5ib2R5LnBhcmVudE5vZGUuc2Nyb2xsSGVpZ2h0IHx8IGRvY3VtZW50LmJvZHkuc2Nyb2xsSGVpZ2h0KVxuICAgIHJldHVybiB7IHNjcm9sbFRvcCwgc2Nyb2xsSGVpZ2h0IH1cbiAgfVxuXG4gIF9pc0F0Qm90dG9tICgpIHtcbiAgICBjb25zdCB7IHJvb3RFbCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IHsgc2Nyb2xsVG9wLCBzY3JvbGxIZWlnaHQgfSA9IHRoaXMuX2dldFNjcm9sbERpbWVuc2lvbigpXG4gICAgY29uc3Qgd2luSCA9IHJvb3RFbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsKS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5oZWlnaHQgOiB3aW5kb3cuaW5uZXJIZWlnaHRcbiAgICBjb25zdCBzY3JvbGxlZFRvQm90dG9tID0gKHNjcm9sbFRvcCArIHdpbkgpID49IHNjcm9sbEhlaWdodFxuICAgIHJldHVybiBzY3JvbGxlZFRvQm90dG9tXG4gIH1cblxuICBfaXNTY3JvbGxlZCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2dldFNjcm9sbERpbWVuc2lvbigpLnNjcm9sbFRvcCA+IDBcbiAgfVxuXG4gIF9nZXRTY3JvbGxlZFBhc3QgKHZpZXdTdGF0dXNMaXN0KSB7XG4gICAgaWYgKCF2aWV3U3RhdHVzTGlzdC5zb21lKChpdGVtKSA9PiBpdGVtKSkgeyByZXR1cm4gdmlld1N0YXR1c0xpc3QgfVxuICAgIGxldCBoYXNGb3VuZEluVmlldyA9IGZhbHNlXG4gICAgY29uc3Qgc2Nyb2xsZWRQYXN0SXRlbXMgPSB2aWV3U3RhdHVzTGlzdC5tYXAoKGl0ZW0pID0+IHtcbiAgICAgIGlmIChpdGVtICYmICFoYXNGb3VuZEluVmlldykge1xuICAgICAgICBoYXNGb3VuZEluVmlldyA9IHRydWVcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgICByZXR1cm4gIWhhc0ZvdW5kSW5WaWV3XG4gICAgfSlcbiAgICByZXR1cm4gc2Nyb2xsZWRQYXN0SXRlbXNcbiAgfVxuXG4gIF91cGRhdGUgKHByZXZTdGF0dXNlcykge1xuICAgIGNvbnN0IHsgaW5WaWV3U3RhdGUsIHRhcmdldEl0ZW1zIH0gPSB0aGlzLnN0YXRlXG4gICAgaWYgKEhlbHBlcnMuaXNFcXVhbEFycmF5KGluVmlld1N0YXRlLCBwcmV2U3RhdHVzZXMpKSB7IHJldHVybiB9XG4gICAgdGhpcy5wcm9wcy5vblVwZGF0ZSh0YXJnZXRJdGVtc1tpblZpZXdTdGF0ZS5pbmRleE9mKHRydWUpXSlcbiAgfVxuXG4gIG9mZkV2ZW50KCkge1xuICAgIGxldCB7IHJvb3RFbCB9ID0gdGhpcy5wcm9wc1xuICAgIGNvbnN0IGVsID0gcm9vdEVsID8gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcihyb290RWwpIDogd2luZG93XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Nyb2xsJywgdGhpcy5faGFuZGxlU3B5KVxuICB9XG5cbiAgb25FdmVudCgpIHtcbiAgICBsZXQgeyByb290RWwgfSA9IHRoaXMucHJvcHNcbiAgICBjb25zdCBlbCA9IHJvb3RFbCA/IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Iocm9vdEVsKSA6IHdpbmRvd1xuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ3Njcm9sbCcsIHRoaXMuX2hhbmRsZVNweSlcbiAgfVxuXG4gIGNvbXBvbmVudERpZE1vdW50ICgpIHtcbiAgICB0aGlzLl9pbml0UHJvcHMoKVxuICAgIHRoaXMuX3NldExpc3RJdGVtcygpXG4gICAgdGhpcy5vbkV2ZW50KClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50ICgpIHtcbiAgICB0aGlzLm9mZkV2ZW50KClcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxSZWNlaXZlUHJvcHMgKCkge1xuICAgIHRoaXMuX2luaXRGcm9tUHJvcHMoKVxuICB9XG5cbiAgX3NldFNjcm9sbFNlbGVjdE5hdigpIHtcbiAgICB0aGlzLm9uRXZlbnQoKVxuICAgIGNvbnN0IHsgaW5WaWV3U3RhdGUsIGl0ZW1zIH0gPSB0aGlzLnN0YXRlXG4gICAgaWYoIGluVmlld1N0YXRlLmluZGV4T2YodHJ1ZSkgIT09IC0xICkge1xuICAgICAgbGV0IGhhc2gsIGN1cnJlbnRIYXNoLCBpbmRleFZpZXcgPSBpblZpZXdTdGF0ZS5pbmRleE9mKHRydWUpXG4gICAgICBoYXNoID0gaXRlbXNbaW5kZXhWaWV3XVxuICAgICAgY3VycmVudEhhc2ggPSB3aW5kb3cubG9jYXRpb24uaGFzaC5zcGxpdCgnIycpWzFdXG4gICAgICBsZXQgY3VycmVudEluZGV4ID0gaXRlbXMuaW5kZXhPZihjdXJyZW50SGFzaClcbiAgICAgIGlmICggaGFzaCApIHtcbiAgICAgICAgaWYoIGN1cnJlbnRJbmRleCA8IGluZGV4VmlldyApIHtcbiAgICAgICAgICB3aW5kb3cubG9jYXRpb24uaGFzaCA9ICcjJyArIGhhc2hcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCB7IGNoaWxkcmVuLCBjbGFzc05hbWUgPSAnJywgdGFnIH0gPSB0aGlzLnByb3BzXG4gICAgY29uc3QgeyBpblZpZXdTdGF0ZSB9ID0gdGhpcy5zdGF0ZVxuICAgIGNvbnN0IFRhZ0NvbXBvbmVudCA9IHRhZ1xuICAgIGxldCBjb3VudGVyID0gMFxuICAgIGNvbnN0IGl0ZW1zID0gUmVhY3QuQ2hpbGRyZW4ubWFwKGNoaWxkcmVuLCAoY2hpbGQsIGlkeCkgPT4ge1xuICAgICAgaWYgKCFjaGlsZCkge1xuICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgfVxuICAgICAgY29uc3QgQ2hpbGRUYWcgPSBjaGlsZC50eXBlXG4gICAgICBjb25zdCBlbGVtZW50SUQgPSB0aGlzLl9nZXRMZXZlbENoaWxkcmVuKGNoaWxkLnByb3BzKVxuICAgICAgY29uc3QgY2hpbGRDbGFzcyA9IGNsYXNzTmFtZXMoe1xuICAgICAgICBbYCR7IGNoaWxkLnByb3BzLmNsYXNzTmFtZSB9YF06IGNoaWxkLnByb3BzLmNsYXNzTmFtZSB8fCAnJyxcbiAgICAgICAgW2AkeyB0aGlzLnByb3BzLmFjdGl2ZSB9YF06IGluVmlld1N0YXRlW2lkeF1cbiAgICAgIH0pXG4gICAgICB0aGlzLl9zZXRTY3JvbGxTZWxlY3ROYXYoKVxuICAgICAgcmV0dXJuIChcbiAgICAgICAgPENoaWxkVGFnIHsgLi4uY2hpbGQucHJvcHMgfSBjbGFzc05hbWU9eyBjaGlsZENsYXNzIH0ga2V5PXsgY291bnRlcisrIH0gb25DbGljaz17KGV2ZW50KSA9PiB0aGlzLmdvU2Nyb2xsVGFnKGV2ZW50LCBlbGVtZW50SUQpfSA+XG4gICAgICAgICAgeyBjaGlsZC5wcm9wcy5jaGlsZHJlbiB9XG4gICAgICAgIDwvQ2hpbGRUYWc+XG4gICAgICApXG4gICAgfSlcblxuICAgIHJldHVybiAoXG4gICAgICA8VGFnQ29tcG9uZW50IGNsYXNzTmFtZT17IGNsYXNzTmFtZSB9PlxuICAgICAgICB7IGl0ZW1zIH1cbiAgICAgIDwvVGFnQ29tcG9uZW50PlxuICAgIClcbiAgfVxufVxuIl19